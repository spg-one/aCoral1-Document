\chapter{Bootloader}
\section{什么是Bootloader}
我们将 Bootloader 拆开来看，
一个是 boot,一个是 loader，可见 Bootloader 有两个主要特性:

(1) Boot。
Boot的原意为靴子，在计算机领域引申为启动，也就是说系统启动时会从这里启动，具体一点就是当
我们按开机键，cpu 执行的第一条指令就应该是 Bootloader 的代码。

(2) Loader。
Loader是加载的意思。那自然就可以引出三个问题：加载什么（what）、怎么加载（how）、从哪里加载（from）、加载到哪里去（to）以及为什么要加载（why）。
加载什么？当然是加载代码程序，这个程序就是我们经常谈到的内核映像——像 linux 内核，window 内核，亦或是aCoral的内核等。
怎么加载？加载说白了就是复制，将内核代码原封不动的从一个地方复制到另一个地方。
从哪里加载？自然是从放着内核代码的地方加载了，常见的存储介质有 flash、SD 卡等。
加载到哪里去？自然是加载到内核要运行的地方——内存，常见的有 SDRAM、DDR 等。
为什么要加载？这就不是一句两句能说清楚的了。简单来讲，因为 flash、SD 卡这些非易失性存储器不能用来运行程序，或者不适合运行程序，但是他们便宜，容量大，断电也不会丢失数据，适合存放程序，我们一般称为外存。
而SDRAM、DDR这些易失性存储器不能用来在断电的情况下存放程序，但是在通电之后运行速度快，适合运行代码，一般称为内存。所以，上电之后需要通过 loader 来把内核程序从外存复制到内存中，这样内核程序就能正常运行了。

在嵌入式系统中，常见的Bootloader有 vivi,uboot ，这些程序都是开机时
就启动的，它启动后，会从 flash 或 sd 卡等存储设备中将内核程序代码拷贝
到 sdram,然后执行内核代码。

如果你曾经接触过vivi、uboot这些开源的bootloader，就会发现，这些bootloader似乎都没有这么简单，大小也都往往几MB往上，这是为什么呢？
有两个主要原因：
(1) 它们都支持多平台，它们都可以看成一个通用的 Bootloader。
(2) 除了提供上面启动，加载两个功能外，它们还支持更多功能，比如支持各种命令，比如操作 nandflash,norflash,EEPROM，支持 ftp,tftp,nfs 等网络协议，又或者支持 usb 下载等功能。
有些 Bootloader 如 arm 公司的 bootmonitor 还支持文件系统，能以文
件系统的方式管理 nandflash,sdcard,compact card 上的数据。
有了上面两大类的支持后，Bootloader 不再是纯粹的 Bootloader,都有了操
作系统的一些功能，只是不支持操作系统支持的任务切换功能。

aCoral的bootloader其实就是 
\begin{lstlisting}
 hal/s3c2440/src/start.S 
\end{lstlisting}
这个文件。它就没有这么多复杂的功能了，仅仅做了bootloader最本职的两个工作：启动、加载。关于这个文件的解析，将在后面详细阐述。


\section{loader}
关于为什么要加载（why）这个问题，这一小节就来细说。如果你对这一部分没有特别强烈的求知欲，可以暂时先跳过，以后再来阅读。
我们的程序代码存放或者运行的地方称为存储介质。储存介质选择的主要参考：速度，尺寸，价格。存储介质按照不同的方法，可以分为不同的种类。

1)按存取方式分类
如果存储器中任何存储单元的内容都能被随机存取，且存取时间和存储单元
的物理位置无关，这种存储器称为随机存储器。半导体存储器和磁芯存储器都是
随机存储器。如果存储器只能按某种顺序来存取，也就是说存取时间和存储单元
的物理位置无关，这种存储器称为顺序存储器。例如，磁带存储器就是顺序存储
器。一般来说，顺序存储器的存取周期较长。磁盘存储器是半顺序存储器。

2)按存储器的读写功能分类
有些半导体存储器存储的内容是固定不变的，即只能读出而不能写入，因此
这种半导体存储器称为只读存储器 (ROM)。既能读出又能写入的半导体存储器，
称为随机存储器 (RAM)。

3)按信息的可保存性分类
断电后信息即消失的存储器，称为易失性存储器，或者非永久记忆的存储器。断电后仍能保存信
息的存储器，称为非易失性存储器，或永久性记忆的存储器。磁性材料做成的存储器是永久性存储器，
半导体读写存储器 RAM 是非永久性存储器。

我们常见的储存介质大类有：磁带，硬盘，ROM，RAM,具体到嵌入式：经常用到是
norflash,nandflash,sdcard,TF 卡，compact 卡，sdram,ram 等。为什么会出现这
么多种类？这个是价格和需求平衡的结果。
比如,我们知道程序最后运行必须要有随机可读写存储器来存储变量，且速度
要快，这个导致了 RAM 的产生，但是 RAM 价格昂贵，又导致了 sdram 的产生，sdram
和 ram 的区别就是它是靠电容的值来保存 0，1 信息，时间一长就会丢失数据，故
需要周期性刷新，这个在 sdram 控制器芯片的控制下能很好解决，且不太影响性
能，但是它速度比 ram 低一些，且复杂些，但是价格低很多，且容易做到很大，
故是一种很好的储存器，因此目前无论是嵌入式还是 pc 设备都广泛使用到了sdram。
虽然 sdram 解决了可读写问题，且速度问题。但是它们都是非永久记忆的存
储器，断电后信息即消失的存储器，明显不能满足我们要求永久保存我们代码的
需求，你总不至于，每次启动电脑都要下载一次程序吧，于是就产生 nandflash,硬
盘这些永久记忆的存储器（硬盘太大，很少用在嵌入式系统中），这些储存器是永
久，且能做到很大容量，但是速度慢，不过还是可以承受的，因为我们有办法解
决这个问题？如何解决，就是前面说的加载，就是说在启动阶段，Bootloader 启动
后就从这些储存介质拷贝程序到 sdram，这样真正运行时，代码和数据是从 sdram
中读取的，也就没有速度问题了，这也是为啥要 Bootloader 的原因。

有了 nandflash,硬盘这些永久记忆的存储器还不够，为啥？因为它们是按块
访问的，而不是按地址访问，这种块模式访问往往需要有硬件控制器，而硬件控
制器又需要由程序来控制，那这个控制器的程序从何而来？这就是鸡生蛋，蛋生
鸡的问题，正因为这样又出来一种存储器——ROM，比如 norflash,只读存储器，
这种储存器也是永久记忆的存储器，但它和 nandflash 等不一样，它是按地址随
机访问的，也就是说不需要驱动，和 sdram 的访问方式一样，可以很简单的访问
数据，这就解决了这个问题，但是这种按地址访问的永久记忆的存储器相比有点
贵，且不能做到很大。其实也没必要过多的使用这中存储器，为啥？因为它是只
读的，没法修改，不会过多使用，所以只要能够容下 Bootloader 这些程序就可以
了，其他的代码交给廉价的可写的 nandflash 吧，当然对于代码还是可以一直放
在 rom 中的，这样可以减少 Sdam 的使用。

也许你会说为啥不出产一种按地址访问的可读写永久记忆的存储器，是可以
啊，但是代价太高，没必要，只要合理搭配，就可以满足需求，当然不排除有一
天，按地址访问的可读写永久记忆的存储器很便宜了，但是这个世界没有完美的
东西，优点越多，缺点也越多。

下面就来说下嵌入式储存器搭配问题：
硬盘肯定是不到万不得已，是不选择的，因为这个家伙体积大，功耗大，也
不安静，不过对于需要储存上 10G 的数据的应用，还不得不用它。
Bootloader 程序的储存器肯定得要是按地址随机存取的永久性记忆的存储器，
当然对于支持 nandflash 启动的 soc，也可以储存在 nandflash,比如 s3c2410,2440,
同时又比如 omap3530 是支持 sdcard 启动的，这样的 SOC 芯片也是可以将
Bootloader 放在 sdcard 上的。
也许到了这里，你会有一种强烈的好奇性？刚才不是说 nandflash,sdcard 都
是需要控制器才能访问数据的啊，控制器又需要程序，上面的 s3c2410,omap3530
等芯片是如何做到从这些地方启动的。
其实解决方法和我们上面探讨的一样，就是必须有一个拷贝动作，这个拷贝
动作可以有三种方式，一种是硬件方式，另一种是软件方式
1）硬件方式：
就是硬件实现储存设备控制器的控制，读取指定大小的数据，它没法做到控制
器的驱动程序那样，可以随机读取任意大小的数据，但是只要能够拷贝指定地址
指定大小的数据，就已经够了，硬件可以看成是简化版的驱动
2）软件方式： 
这个就更简单了，芯片自带一个 ROM,往往是片内 ROM,这个 ROM 里装有驱动程
序，这个驱动程序负责将我们的 Bootloader 从 nandflash 或 sdcard 等储存器拷
贝到 sdram 或 ram 后，然后跳到我们的 Bootloader 运行，这样其实和我们将
Bootloader 储存在 rom 是一样的，只不过板子自带了一个 Bootloader,这个简单
的 Bootloader 先于我们的 Bootloader 运行，主要实现小量数据（至少包括我们
的 Bootloader 的自我拷贝代码）拷贝。
其实还有另外一种启动技巧，那就是内存映射：
就是说当用户使用跳线选择方式后，硬件自动开启了内存映射，将其他内
存地址映射到 cpu 启动地址，比如 pb11mpcore，cpu 的启动地址是 0x0,如果配置
为 Norflash 启动，则可将 norflash 的地址 0x40000000~0x43FFFFFF 映射到
0x0~0x3ffffff,这样就相当于从 norflash 启动，这种方式是经常用的方式。由于
内存映射到地址 0x0 了，导致地址 0x0 对应的的内存没法使用，因此启动后需将
这个映射取消
这种和上面的方式不同，这种需要有按地址随机存取存储器的支持，即将储
存启动代码的存储器的地址映射到启动地址。

说完 Bootloader 的储存介质，就得说说操作系统（通常叫 kernel）映像文件
的储存介质。
嵌入式操作系统这类操作系统一般比较小，选择余地有很多，可以放在 rom
中，也可以放在 nandflash 中，因为不论放在哪里，只要 Bootloader 能找到，拷
贝到 sdram 就可以了，所以关键看 Bootloader 是否强大，对于很强大的 Bootloader，
其实操作系统都可以放在主机上，然后 Bootloader 可以通过网络将操作系统下载
到 sdram，然后启动操作系统。
对于 Bootloader 和内核链在一起的操作系统，操作系统肯定就是跟
Bootloader 一起储存在一种储存介质中了啊。
